# DÉVELOPPEMENT D'OUTILS CRYPTOGRAPHIQUES
## Highlight
Cryptographie asymétrique = cryptographie faisant intervenir 2 clés: 
- clé publique: transmettre à l'envoyeur et lui permet de chiffrer son message
- clé secrète *(aka. privée)*: déchiffrer les messages à la réception 

### Protocol RSA
- algo de cryptographie asymétrique
	- très utilisé pour transmettre des données confidentielles
- s'appuie sur des nombres premiers pour la génération des clés publiques et privées

# Résolution du problème de primalité
>**Question**: Étant donné un entier $p$ impair, $p$ est-il un nombre premier ?

## Implémentation par une méthode naive
```c
int is_prime_naive(long p);
```

1. Énumérer tous les entiers entre $3$ et $p-1$
2. Conclure que $p$ est premier si et seulement si aucun de ces entiers ne divise $p$


## Exponentiation modulaire rapide
### Preliminary
Pour parvenir à générer de très grand nombres premiers, nécessaires au bon fonctionnement du protocole RSA $\to$ implémenter un test de primalité plus efficace: celui de Miller-Rabin. 

Ce test **probabiliste** nécessite de pouvoir calculer efficacement une exponentiation modulaire, ie. $a^m \mod n$, étant donnés 3 entiers $a, m, n$. 

### Principe
>Calculer $a^m \mod n$, sans passer par le calcul de $a^m$

- multiplier la valeur courante par $a$
- applique **modulo** $n$ sur le résultat, avant de passer à l'itération suivante
- répéter ces opérations $m$ fois
```c
long modpow_naive(long a, long m, long n);
```

Au lieu de multiplier par $a$ à chaque itération: réaliser des élévations au carré *(directement suivies de $mod$)* pour obtenir un algorithme de complexité logarithmique $O(\log_{2}(m))$ 
```c
int modpow(long a, long m, long n);
```
Pour une version récursive, il suffit de remarquer que $a^b\mod n$ est égal à 
- **BASE**: $1$ quand $m=0$
- **INDUCTION**: 
	- $b*b\mod n$ avec $b=a^{m/2}\mod n$, quand $m$ est pair
	- $a*b*b\mod n$ avec $b=a^{\lfloor{m/2}\rfloor}\mod n$, quand $m$ est impair
>**Attention**: à chaque appel, au plus un appel récursif est à effectuer

**Additional**: Tracer des courbes de temps en fonction de $m$

## Test de Miller-Rabin
Test de primalitié de Miller-Rabin: algorithme randomisé utilisant la propriété suivante:

Soit $p$ un nombre **impair** quelconque. 

Soient $b$ et $d$ deux entiers tels que $p=2^b*d+1$.

Étant donné un entier $a$ strictement inférieur à $p$, on dit que $a$ est un témoin de Miller pour $p$ si: 
- $a^d\mod p \neq1$ 
- $a^{2^r*d}\mod p\neq-1$ pour tout $r\in \{0,1....,b-1\}$

Si $a$ est un témoin de Miller pour $p$, alors il est possible de prouver que $p$ n'est pas premier. 

Dans le cas contraire, on ne peut pas dire que $p$ est premier.

Par contre, si on répète ce test suffisamment de fois, pour des valeurs de $a$ tirées au hasard entre $1$ et $p-1$, et qu'aucune de ces valeurs générées ne correspond à un témoin de Miller pour $p$, alors on peut dire que $p$ est très probablement premier. 

### Fonctions fournies
1. `int witness(long a, long b, long d, long p)`: teste si $a$ est un témoin de Miller pour $p$, pour un entier $a$ donné
2. `long rand_long(long low, long up)`: retourne un entier `long` généré aléatoirement entre `low` et `up` inclus
3. `int is_prime_miller(long p, int k)`: 
	- réalise le test de Miller-Rabin en générant $k$ valeurs de $a$ au hasard, et en testant si chaque valeur de $a$ est un témoin de Miller pour $p$.
	- retourne 
		- $0$ dès qu'un témoin de Miller est trouvé ($p$ pas premier)
		- $1$ si aucun témoin de Miller n'a été trouvé ($p$ très probablement premier)
