# DÉVELOPPEMENT D'OUTILS CRYPTOGRAPHIQUES
## Highlight
Cryptographie asymétrique = cryptographie faisant intervenir 2 clés: 
- clé publique: transmettre à l'envoyeur et lui permet de chiffrer son message
- clé secrète *(aka. privée)*: déchiffrer les messages à la réception 

### Protocol RSA
- algo de cryptographie asymétrique
	- très utilisé pour transmettre des données confidentielles
- s'appuie sur des nombres premiers pour la génération des clés publiques et privées

# Résolution du problème de primalité
>**Question**: Étant donné un entier $p$ impair, $p$ est-il un nombre premier ?

## Implémentation par une méthode naive
```c
int is_prime_naive(long p);
```

1. Énumérer tous les entiers entre $3$ et $p-1$
2. Conclure que $p$ est premier si et seulement si aucun de ces entiers ne divise $p$


## Exponentiation modulaire rapide
### Preliminary
Pour parvenir à générer de très grand nombres premiers, nécessaires au bon fonctionnement du protocole RSA $\to$ implémenter un test de primalité plus efficace: celui de Miller-Rabin. 

Ce test **probabiliste** nécessite de pouvoir calculer efficacement une exponentiation modulaire, ie. $a^m \mod n$, étant donnés 3 entiers $a, m, n$. 

### Principe
>Calculer $a^m \mod n$, sans passer par le calcul de $a^m$

- multiplier la valeur courante par $a$
- applique **modulo** $n$ sur le résultat, avant de passer à l'itération suivante
- répéter ces opérations $m$ fois
```c
long modpow_naive(long a, long m, long n);
```

Au lieu de multiplier par $a$ à chaque itération: réaliser des élévations au carré *(directement suivies de $mod$)* pour obtenir un algorithme de complexité logarithmique $O(\log_{2}(m))$ 
```c
int modpow(long a, long m, long n);
```
Pour une version récursive, il suffit de remarquer que $a^b\mod n$ est égal à 
- **BASE**: $1$ quand $m=0$
- **INDUCTION**: 
	- $b*b\mod n$ avec $b=a^{m/2}\mod n$, quand $m$ est pair
	- $a*b*b\mod n$ avec $b=a^{\lfloor{m/2}\rfloor}\mod n$, quand $m$ est impair
>**Attention**: à chaque appel, au plus un appel récursif est à effectuer

**Additional**: Tracer des courbes de temps en fonction de $m$

